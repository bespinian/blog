<!DOCTYPE html>
<html lang="en-us">
    <head>
		
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-132338301-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Git - The Important Parts &middot; bespinian Blog</title>

		
		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		<link rel="stylesheet" href="/custom.css">
		
		<link rel="icon" href="/favicon.ico"/>
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="" rel="alternate" type="application/rss+xml" title="bespinian Blog" />

		<script src="/js/darkmode.js"></script>
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					
						<h2 class="nav-title">bespinian Blog</h2>
					
				</a>
				<ul>
    
    
</ul>
			</div>
		</nav>

        <div id="darkModeToggle" onclick="toggleDarkMode()">
  &#9680; 
</div>

        

<main>
	


        <div class="post">
		<div class="post-info">
    <span>Written by</span>
        Lena Fuhrimann / Mathis Kretz
        <br>
        <span>on&nbsp;</span><time datetime="2021-10-15 00:00:00 &#43;0000 UTC">October 15, 2021</time>
</div>

		<h1 class="post-title">Git - The Important Parts</h1>
<div class="post-line"></div>

		

		<p>This blog post is the first part of a three-part series adapted from a GitOps webinar series which we co-produced together with our friends at <a href="https://www.vshn.ch/">VSHN</a>.</p>
<p>In this first part we will look at Git and what is important when using it in a team. The second part will be about Infrastructure as Code, a handy concept which helps to unify environments and be aware of the exact changes made to different parts of your infrastructure. In the third and last part, we will combine these ideas and delve into the concept of GitOps. Following these principles can help your team to improve the communication, investigate issues more easily and work more efficiently. Be aware though, that there are several caveats when adapting these concepts. That’s why we will also look into some common pitfalls and speak about our experience getting teams started with these tools.</p>
<p>If you have questions, feel free to post them as comments on this blog post. If you would rather sit back and enjoy this part as a webinar, then you may head over to <a href="https://www.youtube.com/watch?v=jGEDq4gz3zA">the recording on YouTube</a>.</p>
<h2 id="what-is-git">What is Git?</h2>
<p>Let’s start by looking into what Git is and how it works. Git is a very common version control system that has evolved into one of the standard tools for modern software development. It helps us to keep track of changes to our source code. When collaborating in a team, it lets each developer work on their feature on a separate copy of the code without getting into each other&rsquo;s way.</p>
<p>Furthermore, Git allows us to easily travel the history of our source code and understand changes by looking at the order they were made in and read the small pieces of documentation their authors have left us. This is hugely helpful when debugging code other people have written or even code which I myself have written some time ago. I can jump around different points in time, see individual changes and even revert them to create a new fixed release.</p>
<p>We may take this for granted but think about how finicky working with code in a big team would be without these features.</p>
<h2 id="commit-messages">Commit Messages</h2>
<p>As you may already know, in Git developers make changes to source code in the form of so-called commits. A commit is a small set of changes to one or multiple files and contains information about the author and the time the changes were made.</p>
<p>In order to be able to understand these changes, developers are asked to document their commits with small pieces of text called “commit messages”. The quality of these is a vital part of the health of our code base. Making good commit messages helps our teammates and future selves to understand the purpose of changes and specific ways of implementation. If done well, they provide crucial information at a glance and are structured in a way that lets us browse and even search the history of changes of our code base.</p>
<h3 id="bad-commit-messages">Bad Commit Messages</h3>
<p>First, let’s have a look at some bad commit messages and why they are bad. Then, we will look into how to improve them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;</span>
</span></span></code></pre></div><p>The worst commit message is obviously an inexistent one. Not adding a message to our commit is luckily considered bad practice by most engineers. It gives someone who browses our changes no context at all and leaves them to figure out the effect and purpose of our changes by themselves. It also does not make developers think about their changes and why they are making them in a certain way. This process is important because it helps developers make more conscious and focused changes.</p>
<p>A meaningless commit message like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>did some stuff, now it works.
</span></span></code></pre></div><p>is clearly not much more helpful than not having a message at all.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Extended the flux capacitor and added a left-trim feature to the tractor beam and implemented the emergency self-destruct button.
</span></span></code></pre></div><p>Another indicator of a bad message is a very long commit message that contains the word “and” one or even multiple times. First, long messages are not easy to read and comprehend. Secondly, they strongly suggest that too many unrelated changes were crammed into a single commit. Such commits are hard to understand and manage and should be omitted. It is much easier to understand a set of small changes with a clear history documented in their individual messages than a huge commit which contains unrelated changes.</p>
<h3 id="good-commit-messages">Good Commit Messages</h3>
<p>Good commit messages on the other hand are clear and concise. They describe what the changes of the commit do in a human-readable way and do not contain any superfluous punctuation or words. Good examples are</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Upgrade lodash dependency
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Fix typo in README
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Return correct error codes <span style="color:#66d9ef">for</span> all errors
</span></span></code></pre></div><p>These examples can easily be read and understood without knowing the whole context of the application.</p>
<p>So, in summary, the most important rule about good commit messages is to write them at all and to write them in a concise format that can easily be understood by others and our future self.</p>
<h3 id="commit-message-body">Commit Message Body</h3>
<p>So far, we have only covered the subject of a commit message which is the first line. Most people use only the subject line to describe their change, which is sufficient for almost any commit. If, however, a commit is a bit more involved or the changes and the rationale behind it cannot be easily understood, it can be helpful to explain the commit in a more verbose form. That’s what the body of a commit message is for. Here you can see an example of a commit message containing a concise subject line and a body that explains it further.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Return correct error codes <span style="color:#66d9ef">for</span> all errors
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>We used to always <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">500</span> error codes from our HTTP API. This is not according to the HTTP specification. Because of that, this commit changes the API to <span style="color:#66d9ef">return</span> correct 4XX and 5XX error codes respectively.
</span></span></code></pre></div><p>The body is separated from the first line by a blank one and is written in proper language to make it easily readable for our peers. It is mostly used to explain why a commit was made. If necessary, it can also be used to explain the changes themselves in a more explicit way if they cannot be understood intuitively.</p>
<h3 id="commit-message-guidelines">Commit Message Guidelines</h3>
<p>In order to write proper commit messages, there are a few guidelines to follow. This helps us to standardize the formatting of commits within our team and to follow the guidelines Git itself abides to when making commits, for example when it creates a merge commit.</p>
<h4 id="separate-the-subject-from-the-body-with-a-blank-line">Separate the subject from the body with a blank line</h4>
<p>Firstly, we should separate the subject from the body with a blank line if there is a body at all. This helps Git tooling to parse the commit message correctly and for human eyes to quickly see that there is a subject line and a separate body that helps us further understand the rationale behind the commit.</p>
<h4 id="limit-the-subject-line-to-50-characters">Limit the subject line to 50 characters</h4>
<p>Secondly, it is helpful to limit the subject line to around fifty characters. This is first and foremost a guide to keeping our messages concise and let people browse them more easily when reading a list of commits to find the right one. But it also makes sense because much of the Git tooling out there cannot show an unlimited amount of characters when displaying commit messages.</p>
<h4 id="capitalize-the-subject-line">Capitalize the subject line</h4>
<p>The third good practice is to capitalize the subject line of a Git commit message. That makes it easier for people to see where it starts and to read it because it feels more natural.</p>
<h4 id="do-not-end-the-subject-line-with-punctuation">Do not end the subject line with punctuation</h4>
<p>The fourth guideline is that using punctuation in a commit messages unnecessarily makes it longer. Mostly commit messages are not proper sentences and don’t deserve a period at the end anyway.</p>
<h4 id="use-the-imperative-mood-in-the-subject-line">Use the imperative mood in the subject line</h4>
<p>The fifth guideline is to use the imperative mood when writing them. That means to write them in the present tense and make them sound like an order. A good way of checking if your message follows this guideline is to think the sentence “If applied, this commit will…” and then appending your message. If that creates a sentence of proper English, you most likely used the imperative mood correctly.</p>
<p>There are also certain guidelines for the message body.</p>
<h4 id="wrap-the-body-at-72-characters">Wrap the body at 72 characters</h4>
<p>Number six: The body should be wrapped at around 72 characters. The reason being that human eyes can most easily process text at that width. Since the body can contain long sentences of prose, it is helpful for readers to have the width limited to that amount.</p>
<h4 id="use-the-body-to-explain-what-and-why-versus-how">Use the body to explain what and why versus how</h4>
<p>The last and seventh good practice is to use the body to further explain the what and why of our changes. It should help a reader understand what changes were made and the reasoning behind the changes. It should not explain the code itself and tell the reader how the changes were made or how a certain problem was solved. That’s what code comments or actually intuitively written code is for.</p>
<h2 id="branching-strategies">Branching Strategies</h2>
<p>Another important part to using Git are branches. You have probably used them maybe to hold a specific feature that is not ready yet or just to try something out. When working in a team, it is essential to adhere to a branching strategy everyone agrees upon. Depending on the size of your team and the complexity of the application it develops and releases, different ways of using Git can make sense. In the following, we will have a look at two of the most common branching strategies and when they make sense.</p>
<h3 id="gitflow">Gitflow</h3>
<p><img src="./gitflow.png" alt=""></p>
<p>The first strategy is called “Gitflow”. It allows to easily collaborate and work on multiple features at a time.</p>
<p>The core of Gitflow is the so-called “develop” branch, indicated here in purple, which is where all the work happens. To create a new feature, developers create a feature branch, marked in green in the picture, off the <code>develop</code> branch. They create one or multiple commits on that feature branch until they are happy with their changes and think the feature is fully implemented and tested. As soon as that is done, they create a so-called pull request. That means, they open up their changes for review by their peers before they finally merge everything back into the <code>develop</code> branch. This means that the <code>develop</code> branch should always be in a healthy and deployable state and that feature branches are short-lived because they get deleted once the feature is merged.</p>
<p>The second important branch in Gitflow is the <code>master</code> or <code>main</code> branch, highlighted in blue, which contains only code that has already been released. It ideally contains one commit per release which is tagged with the respective release number and should always remain stable and releasable.</p>
<p>But how do commits get from <code>develop</code> to the main branch?</p>
<p>Once the <code>develop</code> branch is ready to be released, a new release branch, highlighted here in teal, is created off the <code>develop</code> branch where all the commits that should be part of this release are collected. This can happen via completely releasing the <code>develop</code> branch as is or by cherry-picking certain commits from “develop” into the release. Once the release is ready, the respective branch gets merged into the <code>master</code> branch and properly tagged as a clean release and then merged back into <code>develop</code>. By doing so, we make sure that there are no changes on the <code>master</code> branch which are not on the <code>develop</code> branch.</p>
<p>Obviously, it can happen that we create a buggy release. For that case, Gitflow introduces the concept of hotfix branches. In the picture we used orange for those. We branch these off the <code>master</code> branch, make our necessary fixes and then merge the hotfix branch back into <code>master</code> but also into develop. With the new <code>master</code> branch containing these changes, we can then create a new release which contains our hotfix.</p>
<p>So, in summary, we have the two main branches <code>main</code> and <code>develop</code> and by creating feature-, release- and hotfix branches we implement new features and hotfixes and merge them between the main branches. This makes Gitflow quite structured yet flexible. However, it introduces some overhead which can especially be a lot of unnecessary strain for smaller teams. For larger and well established teams, it can bring great value and structure to ease communication and collaboration.</p>
<p>A big advantage of Gitflow is that there is quite a lot of tooling around it. One of them is the <a href="https://github.com/nvie/gitflow">Gitflow plugin</a> for the Git CLI which adds handy commands for working with Gitflow. Here is an example of how we would work with the Gitflow Plugin:</p>
<h4 id="initialize-the-project">Initialize the project</h4>
<p>Create a new empty directory and enter it. Then, initialize the project</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git flow init
</span></span></code></pre></div><p>The tool then asks about our team’s naming convention of certain branches, but usually it is good to stick with the defaults. An exception here is the <code>master</code> branch. There has been a change of mind in the last couple of months to rename the <code>master</code> branch to <code>main</code> because the term “master” is politically a bit heavy. For the rest, we can just accept the defaults.</p>
<h4 id="start-a-feature">Start a feature</h4>
<p>To start a feature, Gitflow uses the command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git flow feature start kitten
</span></span></code></pre></div><p>where <code>kitten</code> is the name of the feature. The tool then tells us what it did. It automatically created a new feature branch for us and switched to it. Here, we can make our changes. As an example, we can create a file called <code>kitten.txt</code> which contains the kitten’s name and commit that. By the way, if you don’t provide the <code>-m</code> flag when creating a commit, Git will open your favorite text editor to create the message which is quite handy.</p>
<h4 id="complete-the-feature">Complete the feature</h4>
<p>In order to complete our kitten feature, we just type</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git flow feature finish
</span></span></code></pre></div><p>and the tool automatically merges the feature branch back into develop and switches to it. Obviously, we skipped the step of a pull request here because we are such badass engineers and never make mistakes.</p>
<h4 id="create-a-release">Create a release</h4>
<p>Now that the kitten has been added, we want to release that feature. To do so, we type</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git flow release start 1.0.0
</span></span></code></pre></div><p>where <code>1.0.0</code> is the version number of our release. Again, the tool switches to the newly created release branch. Here we can make changes to prepare the release. For example create a version file that contains the current version number. Now we’ll commit that.</p>
<h4 id="finish-the-release">Finish the release</h4>
<p>Next, we tell the tool that our release is ready by typing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git flow release finish
</span></span></code></pre></div><p>The tool then prompts us to change the commit messages and to add a description to our release tag. As soon as we are done, the changes get merged back into the develop branch and also the main branch with the respective tag.</p>
<p>Looking at our commit log now, shows us that we have a clean history with easily readable commit messages and even one that contains a body describing the release it produced. So, in sum we have a nicely automated process for doing Gitflow!</p>
<h3 id="github-flow">GitHub Flow</h3>
<p><img src="./github-flow.png" alt=""></p>
<p>Next, we will look at another branching strategy called “GitHub Flow”. In contrast to Gitflow, it only contains a single main branch (mostly called <code>master</code> or <code>main</code>) which everything branches off. The main branch is used as the working tree to branch feature branches off. The releasing of software is also done on that single branch. This enforces a strictly linear development process because one can only go forward and not cherry-pick specific changes from one branch to another.</p>
<p>While this may be seen as a restriction by some developers, it can also be a great advantage because it makes it clearer what is released where and which sets of features belong together and into a release. People can view at a glance what features are included in which release and know how the individual releases differ. This makes the workflow simpler and less error-prone but also a bit less flexible. It is therefore more suited for smaller, more agile teams and projects.</p>
<h3 id="merging">Merging</h3>
<p><img src="./merge.png" alt=""></p>
<p>Next we want to look at how we can bring changes from one branch to another. In Git there are two main ways of doing so: merging and rebasing. For both of them we can start with the following example setup which you see in the top half of the picture. Let’s assume that we have a branch named <code>master</code> and a branch named <code>topic</code> which branches off from <code>master</code> at a certain commit E and makes commits A, B and C on top of E. In the meantime the <code>master</code> branch has also evolved further from commit E with commits F and G. Now let’s assume that we want to bring the changes from <code>topic</code> back to <code>master</code>.</p>
<p>If we do this using the mechanism of merging, then all changes from the <code>topic</code> branch are integrated into the <code>master</code> branch in a single new commit H. This new commit is commonly referred to as the merge commit. In the best case the commits F and G which have happened on the <code>master</code> branch in the meantime have only touched parts of files which are not overlapping any parts of the files that were touched in the commits A, B and C on the <code>topic</code> branch. In this case, the merge is executed automatically by Git. In the worst case however, the commits on the <code>topic</code> branch have touched parts in files which were also touched by the commits on the <code>master</code> branch. This is the dreaded merge conflict. In this case, the person who is performing the merge is prompted to manually merge the changes in the conflicted files.</p>
<p>Merge conflicts are how Git resolves the fundamental problem of several people concurrently working on the same set of files. It is fairly normal that they happen occasionally. However, if you have frequent merge conflicts in your project, this usually indicates that something is not right. Either your team might be trying to implement things which somehow contradict each other or parts of your architecture are overloaded because every change needs to touch them or people are not communicating well on who is doing what at which point in time. So, it’s always a good idea to reflect why a particular merge conflict is happening.</p>
<p>Merging has the following properties to keep in mind when comparing it to rebasing: It is very explicit with respect to who performed a merge operation at what point in time. Since a merge is not rewriting any commit history, but only adding one new commit to the target branch, it is also safer to use on branches where lots of people are making concurrent changes.</p>
<h3 id="rebasing">Rebasing</h3>
<p><img src="./rebase.png" alt=""></p>
<p>The other way of bringing changes from the <code>topic</code> branch back to <code>master</code> is using the mechanism of rebasing. Let’s use the same example setting as before which you can see in the top half of the picture. Rebasing the <code>topic</code> branch on the <code>master</code> branch means that we replay all commits from the <code>master</code> branch on the <code>topic</code> branch. In the case of our example this would mean applying commit F on the <code>topic</code> branch and then applying commit G. As we replay each individual commit, merging can either be done by Git automatically or a conflict arises which has to be resolved by a human. The end result of rebasing the <code>topic</code> branch on the <code>master</code> branch is that the <code>topic</code> branch now contains the commits F and G plus the commits A, B and C potentially modified during merge conflict resolution, which is why we call them A’, B’ and C’ in the picture.</p>
<p>Rebasing has the following advantages: Since the commits from the source branch are sequentially reapplied to the target branch the resulting commit history becomes a lot cleaner and easier for humans to read and understand. When rebasing, there are no merge commits cluttering up your history talking about branches that no longer exist.</p>
<h2 id="pull-requests">Pull requests</h2>
<p>Next we will have a look at pull requests, sometimes also referred to as merge requests, depending on which platform you are hosting your Git repos on. Indeed, pull requests are not part of Git itself, but they are featured in all major Git platforms like GitHub, GitLab or Bitbucket. Pull requests are an important tool for collaborating on Git repos and for properly implementing the branching strategies described earlier.</p>
<h3 id="submitting">Submitting</h3>
<p>So let us assume that you have implemented a new feature on a feature branch according to Gitflow.</p>
<p>First, we want to look at some good practices when submitting a pull request for your feature branch. Following these practices will make your reviewer’s life easier which in turn will help you get the most out of their review.</p>
<h4 id="rebase">Rebase</h4>
<p>The first good practice you should follow is making sure that your feature branch is up-to-date with the latest changes on the target branch. After all, you want to make sure that your change works on the current version of develop and not just on a version from way back in time when you branched off your feature branch. Furthermore, you don’t want to place the burden of closing this potential gap on your reviewers. So, according to what we discussed earlier you would now rebase your feature branch on the latest develop branch, meaning that you sequentially apply all commits that have happened on develop since the point in time when you created the feature branch. Let us consider an example. Assume that we are working on a Git repository which contains information on the planets of the Solar System and that our repository initially looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* 2119e4e <span style="color:#f92672">(</span>HEAD -&gt; feature/saturn-to-neptune, origin/feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>* cc9e0d4 Add information on planet Uranus
</span></span><span style="display:flex;"><span>* 4a30b63 Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>* dae16ab Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>* a44fd69 Add information on the planet Saturn
</span></span><span style="display:flex;"><span>| * bc91108 <span style="color:#f92672">(</span>origin/develop, develop<span style="color:#f92672">)</span> Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>| * d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>|/
</span></span><span style="display:flex;"><span>* d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>* 9af8451 <span style="color:#f92672">(</span>origin/main, main<span style="color:#f92672">)</span> Add information on the planet Venus
</span></span><span style="display:flex;"><span>* a1b8fc5 Add information on planet Mercury
</span></span></code></pre></div><p>We can see the feature branch <code>saturn-to-neptune</code> which we are working on and which branches off from <code>develop</code> at the commit which adds information on the planet Earth. In the meantime someone else has added information on the planets Mars and Jupiter on the <code>develop</code> branch. So, before submitting our feature branch for review, we need to bring it up to date with those two additional commits on <code>develop</code>. This we achieve by rebasing our feature branch on <code>develop</code> by executing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git rebase develop
</span></span></code></pre></div><p>while on the feature branch. At this point Git will prompt us to resolve any merge conflicts that might arise from integrating those two commits on our feature branch. If we are lucky, there are none. After potential merge conflicts are resolved, our repository will look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* 1d32960 <span style="color:#f92672">(</span>HEAD -&gt; feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>* f646f96 Add information on planet Uranus
</span></span><span style="display:flex;"><span>* 21fdccb Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>* 6d5b293 Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>* 1abfa9f Add information on the planet Saturn
</span></span><span style="display:flex;"><span>* bc91108 <span style="color:#f92672">(</span>origin/develop, develop<span style="color:#f92672">)</span> Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>* d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>| * 2119e4e <span style="color:#f92672">(</span>origin/feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>| * cc9e0d4 Add information on planet Uranus
</span></span><span style="display:flex;"><span>| * 4a30b63 Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>| * dae16ab Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>| * a44fd69 Add information on the planet Saturn
</span></span><span style="display:flex;"><span>|/
</span></span><span style="display:flex;"><span>* d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>* 9af8451 <span style="color:#f92672">(</span>origin/main, main<span style="color:#f92672">)</span> Add information on the planet Venus
</span></span><span style="display:flex;"><span>* a1b8fc5 Add information on planet Mercury
</span></span></code></pre></div><p>We can see that the local copy of our feature branch is now updated with the two additional commits from <code>develop</code> adding information on Mars and Jupiter. However, the remote copy of the feature branch does not yet contain these commits. We can correct this by force pushing our changes to the feature branch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push --force-with-lease
</span></span></code></pre></div><p>Force pushing is OK in this case, because we are working on the feature branch on our own, so we are not interfering with other potential changes. This will make our repository look as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* 1d32960 <span style="color:#f92672">(</span>HEAD -&gt; feature/saturn-to-neptune, origin/feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>* f646f96 Add information on planet Uranus
</span></span><span style="display:flex;"><span>* 21fdccb Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>* 6d5b293 Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>* 1abfa9f Add information on the planet Saturn
</span></span><span style="display:flex;"><span>* bc91108 <span style="color:#f92672">(</span>origin/develop, develop<span style="color:#f92672">)</span> Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>* d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>* d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>* 9af8451 <span style="color:#f92672">(</span>origin/main, main<span style="color:#f92672">)</span> Add information on the planet Venus
</span></span><span style="display:flex;"><span>* a1b8fc5 Add information on planet Mercury
</span></span></code></pre></div><p>So, we now have a nice and linear history on our feature branch, and we are almost ready to submit the feature branch for review.</p>
<h4 id="review-the-diff">Review the diff</h4>
<p>The next good practice to follow before submitting a merge request is to review the diff which results from your changes. When doing so, you should check that you are only submitting changes which concern the feature you are building. You should take care not to mix these changes with unrelated ones, say dependency updates or code formatting which will make it harder for reviewers to understand what’s going on. If it is not possible to separate the relevant from the unrelated changes this is a clear sign, that you are overloading your pull request.</p>
<h4 id="clean-up-the-commit-history">Clean up the commit history</h4>
<p>Another good practice is cleaning up the commit history of the feature branch. Your reviewers should be able to use the commit history to help them understand the reason for specific changes. Therefore, your feature branch should not contain commits which resulted from trial and error and from changes which are made irrelevant by later commits. But how can we clean up the commit history in hindsight? Once again the rebase command comes in handy, this time rebasing the feature branch on itself.</p>
<p>Considering our example again, we see that the commit history on our feature branch currently contains three commits concerning the planet Saturn:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* 21fdccb Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>* 6d5b293 Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>* 1abfa9f Add information on the planet Saturn
</span></span></code></pre></div><p>It seems that we took at few steps back and forth when making those changes, but those steps are irrelevant for the reviewer, so we want to squash them all into just one commit. We do this using the following command for starting an interactive rebase on the feature branch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git rebase -i --root
</span></span></code></pre></div><p>We specify the option <code>--root</code> to tell Git to show us the whole history for rebasing. This opens our favorite text editor with the Git history and allows us to mark certain commits with a <code>s</code> for squashing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>pick a1b8fc5 Add information on planet Mercury
</span></span><span style="display:flex;"><span>pick 9af8451 Add information on the planet Venus
</span></span><span style="display:flex;"><span>pick d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>pick d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>pick bc91108 Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>pick 1abfa9f Add information on the planet Saturn
</span></span><span style="display:flex;"><span>s 6d5b293 Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>s 21fdccb Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>pick f646f96 Add information on planet Uranus
</span></span><span style="display:flex;"><span>pick 1d32960 Add information on planet Neptune
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Rebase 1d32960 onto f87a562 (10 commands)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Commands:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># p, pick &lt;commit&gt; = use commit</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># f, fixup [-C | -c] &lt;commit&gt; = like &#34;squash&#34; but keep only the previous</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#                    commit&#39;s log message, unless -C is used, in which case</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#                    keep only this commit&#39;s message; -c is same as -C but</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#                    opens the editor</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># .       message (or the oneline, if no original merge commit was</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># .       specified); use -c &lt;commit&gt; to reword the commit message</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># These lines can be re-ordered; they are executed from top to bottom.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># However, if you remove everything, the rebase will be aborted.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span></code></pre></div><p>In this case we have decided to squash the commits <code>21fdccb</code> and <code>6d5b293</code> into <code>1abfa9f</code>. After exiting this dialog, Git asks us what to do with the commit messages of the commits we are about to squash:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># This is a combination of 3 commits.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This is the 1st commit message:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Add information on the planet Saturn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This is the commit message #2:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add some more information on Saturn that I had forgotten before</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This is the commit message #3:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Removed some wrong information about planet Saturn</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Please enter the commit message for your changes. Lines starting</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Date:      Fri Mar 5 22:25:09 2021 +0100</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># interactive rebase in progress; onto f87a562</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Last commands done (8 commands done):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    squash 6d5b293 Add some more information on Saturn that I had forgotten before</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    squash 21fdccb Removed some wrong information about planet Saturn</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Next commands to do (2 remaining commands):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    pick f646f96 Add information on planet Uranus</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    pick 1d32960 Add information on planet Neptune</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># You are currently rebasing branch &#39;feature/saturn-to-neptune&#39; on &#39;f87a562&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Changes to be committed:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#       new file:   saturn.txt</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span></code></pre></div><p>In this case we have chosen to just discard the messages of the commits which are being squashed by commenting them in the editor dialog. After confirming the dialog we see that our repo is now in the following state:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* d61b82e <span style="color:#f92672">(</span>HEAD -&gt; feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>* 548ee1a Add information on planet Uranus
</span></span><span style="display:flex;"><span>* d6db434 Add information on the planet Saturn
</span></span><span style="display:flex;"><span>| * 1d32960 <span style="color:#f92672">(</span>origin/feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>| * f646f96 Add information on planet Uranus
</span></span><span style="display:flex;"><span>| * 21fdccb Removed some wrong information about planet Saturn
</span></span><span style="display:flex;"><span>| * 6d5b293 Add some more information on Saturn that I had forgotten before
</span></span><span style="display:flex;"><span>| * 1abfa9f Add information on the planet Saturn
</span></span><span style="display:flex;"><span>|/
</span></span><span style="display:flex;"><span>* bc91108 <span style="color:#f92672">(</span>origin/develop, develop<span style="color:#f92672">)</span> Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>* d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>* d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>* 9af8451 <span style="color:#f92672">(</span>origin/main, main<span style="color:#f92672">)</span> Add information on the planet Venus
</span></span><span style="display:flex;"><span>* a1b8fc5 Add information on planet Mercury
</span></span></code></pre></div><p>So, the history on the local copy of our feature branch now looks clean. As a last step, we propagate this to the remote copy of the feature branch by force pushing again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push --force-with-lease
</span></span></code></pre></div><p>This will make our repository look entirely clean, ready for our reviewers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>* d61b82e <span style="color:#f92672">(</span>HEAD -&gt; feature/saturn-to-neptune, origin/feature/saturn-to-neptune<span style="color:#f92672">)</span> Add information on planet Neptune
</span></span><span style="display:flex;"><span>* 548ee1a Add information on planet Uranus
</span></span><span style="display:flex;"><span>* d6db434 Add information on the planet Saturn
</span></span><span style="display:flex;"><span>* bc91108 <span style="color:#f92672">(</span>origin/develop, develop<span style="color:#f92672">)</span> Add information on the planet Jupiter
</span></span><span style="display:flex;"><span>* d11edf4 Add information on the planet Mars
</span></span><span style="display:flex;"><span>* d212069 Add information on the planet Earth
</span></span><span style="display:flex;"><span>* 9af8451 <span style="color:#f92672">(</span>origin/main, main<span style="color:#f92672">)</span> Add information on the planet Venus
</span></span><span style="display:flex;"><span>* a1b8fc5 Add information on planet Mercury
</span></span></code></pre></div><h4 id="leave-a-clear-and-concise-title-and-description">Leave a clear and concise title and description</h4>
<p>The last good practice is a very simple one. Write a clear and concise title and description, so that your reviewers immediately know the context in which you are proposing the changes. In a sense the same rules that we have seen for single commit messages also apply here: say in a human-readable form why you are doing something. Additionally, it sometimes makes sense to add instructions for the reviewers which will guide them in reading and understanding your changes, i.e., things like “you should start by looking at the changes in awesome.go and work your way in from there”.</p>
<h3 id="reviewing">Reviewing</h3>
<p>So, now that we know how to submit a pull request, let’s have a look at how to review one.</p>
<h4 id="mentally-sketch-your-own-solution-first">Mentally sketch your own solution first</h4>
<p>Wrapping your head around someone else’s work can be quite daunting. A good way to achieve this is by mentally sketching your own solution to the problem at hand before starting the review. You can then use your mental sketch to guide you through the review and check for specific changes which you would expect to see or not to see. For example when reviewing a pull request described as “Allow users to enter their birthday in their profile” your mental sketch would include the profile screen receiving a new date chooser, the profile API receiving a new date field and the profile database table receiving a new date column. Seeing a change in the shopping cart API would be unexpected and would lead you to ask the author for an explanation.</p>
<p>Apart from having a mental sketch of the expected solution there are a number of further guidelines you should stick to when reviewing a pull request:</p>
<h4 id="be-constructive">Be constructive</h4>
<p>The first one is pretty obvious: be constructive! For every issue you spot, you should not just point out that problem, but you should have a better solution ready to propose to the author. Also, you should always remember that you are reviewing code and not the person who wrote it. Hence, your comments should address weaknesses in the code not in the author.</p>
<h4 id="be-more-than-a-linter">Be more than a linter</h4>
<p>The second guideline is: don’t just be a linter! The whole point of reviews is that they are performed by fellow humans who know the semantics of the problem at hand, the architecture of the system and the design decisions that have been taken to build it. So, expect to dive into the code. Spending your time on correcting indentation errors would be a waste. Indeed, the latter can be done automatically by introducing automated linting.</p>
<h4 id="also-consider-missing-code-and-test-cases">Also consider missing code and test cases</h4>
<p>The third guideline is: also review what isn’t there! It often comes naturally to just look at the code changes which the author of a pull request is proposing. However, that is usually not enough. Instead, you will also have to think about what is missing. This is where your mental sketch again comes in handy. Are there any changes which you would have expected, but you are not seeing? What about tests? Are there any test cases that the author has forgotten, indicating that some boundary conditions were not considered?</p>
<h4 id="perform-large-reviews-interactively">Perform large reviews interactively</h4>
<p>The last guideline is that reviews are performed interactively between the author and the reviewer whenever the pull request exceeds a certain complexity. Pairing up and having synchronous conversations between the reviewer and the author usually saves a lot of back and forth for clarifications. It also helps to avoid misunderstandings and even unnecessary emotions due to people’s different styles in written communication.</p>
<h2 id="git-hooks">Git Hooks</h2>
<p>Until now, we have only described best practices as conventions. In this last part we will have a look at Git Hooks, which enable you to automate and technically enforce certain of these conventions.</p>
<h3 id="use-cases">Use Cases</h3>
<p><img src="./git-hook-use-cases.png" alt=""></p>
<p>Git Hooks are custom scripts which run at certain points in time during the development process. They are defined by scripts which are placed in the .git/hooks directory of your repo. Indeed, if you set up a new Git repo using the <code>git init</code> command, then some example scripts will be automatically created for you in that directory. There are two types of hooks, client-side and server-side hooks.</p>
<p>Client-side hooks run on your machine. By nature client-side hooks are used for checking things in code changes before these changes are allowed to propagate to a remote repository.</p>
<p>There are two client-side hooks which we explicitly recommend. The first one is called pre-commit. It enables you to run checks on your repository before a commit is accepted. This is the ideal place to run your linters and your tests so that no change can ever reach your repository which is not correctly following code formatting rules or which is breaking tests. Checking these things automatically will offload them from the pull request reviewer and allow them focus on more important things.</p>
<p>The second client-side hook we recommend is called commit-msg. As its name suggests, it enables you to run custom code for checking the format of the commit message. Using the commit-msg hook you can easily enforce the commit message guidelines we mentioned earlier.</p>
<p>Server-side hooks run on a Git server. They can be used to check changes which are pushed to that server and possibly reject them. There are two server-side hooks which we want to highlight. The first one is pre-receive which can be used to validate changes and reject them from being pushed to the repo, if necessary. For example, you could use pre-receive to check that no one is merging their own feature branches to develop or is using history changing operations like force pushing on the <code>master</code> branch.</p>
<p>The second server-side hook is post-receive. This hook can be used to react to changes reaching a certain branch. For example, you might want to close a ticket whenever a feature branch is merged to develop.</p>
<p>Now, you might be wondering why we are not mentioning any hooks concerning pull requests. Wouldn’t it be nice to have something like a <code>pre-pullrequest</code> hook to attach logic to pull request creation or pull request approval? Indeed, it would, and some Git platforms are offering features in this direction. However, it is important to note that these are platform specific and not part of Git, as are pull requests themselves.</p>
<p>This brings us to end of the first part of this GitOps blog series. We hope you enjoyed it, and we also hope that you will also enjoy the second part which will be about “Infrastructure as Code”. This next part is coming soon!</p>


		<div
  class="bespinian-social-nav-container bespinian-social-nav-container--footer"
>
  <nav class="bespinian-social-nav">
    
    <a class="bespinian-social-nav-link" href="https://bespinian.io/">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian website">
          <title>bespinian website</title>
          <use href="/icons/globe.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://github.com/bespinian">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on GitHub">
          <title>bespinian on GitHub</title>
          <use href="/icons/github.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://twitter.com/bespinian">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on Twitter">
          <title>bespinian on Twitter</title>
          <use href="/icons/twitter.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://www.youtube.com/channel/UCBQD1IedufccsRXqC_hypyg/playlists">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on YouTube">
          <title>bespinian on YouTube</title>
          <use href="/icons/youtube.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="/index.xml">
      <span class="bespinian-icon">
        <svg role="img" aria-label="The bespinian blog RSS feed">
          <title>The bespinian blog RSS feed</title>
          <use href="/icons/rss.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
  </nav>
</div>

	</div>

	<div class="pagination">
		<a href="/posts/kubernetes-chargeback/" class="left arrow">&#8592;</a>
		<a href="/posts/infrastructure-as-code/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        		<footer>
			
            <figure class="article-discussion">
              <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "berndsgnch" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            </figure>
			
			<span>
			&copy; <time datetime="2022-05-30 08:19:33.199097 &#43;0200 CEST m=&#43;0.150238793">2022</time> bespinian. Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
