<!DOCTYPE html>
<html lang="en-us">
    <head>
		
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-132338301-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>GitOps &middot; bespinian Blog</title>

		
		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		<link rel="stylesheet" href="/custom.css">
		
		<link rel="icon" href="/favicon.ico"/>
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="" rel="alternate" type="application/rss+xml" title="bespinian Blog" />

		<script src="/js/darkmode.js"></script>
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					
						<h2 class="nav-title">bespinian Blog</h2>
					
				</a>
				<ul>
    
    
</ul>
			</div>
		</nav>

        <div id="darkModeToggle" onclick="toggleDarkMode()">
  &#9680; 
</div>

        

<main>
	


        <div class="post">
		<div class="post-info">
    <span>Written by</span>
        Lena Fuhrimann / Mathis Kretz
        <br>
        <span>on&nbsp;</span><time datetime="2022-05-30 00:00:00 &#43;0000 UTC">May 30, 2022</time>
</div>

		<h1 class="post-title">GitOps</h1>
<div class="post-line"></div>

		

		<p>This blog post is the third part of a three-part series adapted from a GitOps webinar series which we co-produced together with our friends at <a href="https://www.vshn.ch/">VSHN</a>.</p>
<p>In this third part, we will show you how you can combine Git, which we introduced in part 1 with Infrastructure as Code, which we introduced in part 2. The combination of these two worlds will lead us to GitOps, where we will show you concepts and technologies which enable you to operate your infrastructure and applications entirely using Git repositories. We will proceed in two steps, first showing you how to do GitOps with applications and then how to extend the same principles to your entire infrastructure stack.</p>
<p>If you have questions, feel free to post them as comments on this blog post. If you would rather sit back and enjoy this part as a webinar, then you may head over to <a href="https://youtu.be/F4ZgpxBCL7s">the recording on YouTube</a>.</p>
<h1 id="the-idea">The Idea</h1>
<p>Before we dive into how we perform GitOps for applications and infrastructure, let’s first consider the general ideas and assumptions behind GitOps.</p>
<p><img src="./idea.svg" alt="Sketch of the general idea: from Git to applications deployed on machines"></p>
<p>Let’s first look at what problem GitOps aims to solve. Applications made up of many microservices are hard to keep track of when deployed in many environments. Environments can easily start to diverge and become snowflakes. GitOps proposes the following solution to this problem: we represent the desired state of our applications and environments declaratively as code, and version this declarative representation in Git. The declarative representation in Git is read by an automatic process, which applies it to the target environment based on certain events. The most important event is when a change happens in the Git repository holding the desired state. However, depending on how strict we want our setup to be, the automatic process could also react to manual changes to the applications or the environment’s infrastructure. In a strict setting, the manual process would override such changes with the desired state from Git. This means that changes to your applications and infrastructure are done exclusively through operations in Git. This in turn means that all the Git goodness that we showed you in Part 1 of this blog series can now be help you with those changes: you automatically get a history of all the changes and of who they were done by. You can pass proposed new changes to team members for a review. You can implement change approval processes using merge requests. Furthermore, your environments automatically stay documented without any extra effort.</p>
<h1 id="declarative-applications">Declarative Applications</h1>
<p>So, in this first part, we want to focus on how you can do GitOps for your applications. Maybe you are part of a team which is building a complex microservice-based application, with another team providing the infrastructure platform to you. Then this first part will already contain all the concepts you need. On the other hand, maybe your team also provisions its own infrastructure. Then the second part on declarative infrastructure will show you how to govern your entire stack with GitOps.</p>
<p>For this first part, we have decided to use Kubernetes as the example infrastructure, which we will assume to be provided to us. There are of course many other examples which we could have used, like AWS Lambda or any other infrastructure platform given to you by a provider.</p>
<h2 id="build">Build</h2>
<p><img src="./build.svg" alt="Diagram showing the phases Lint, followed by Unit Test, followed by Component Test, followed by Build"></p>
<p>Before we can deploy our microservice to an environment, we obviously need to build it. This is usually done with a continuous build pipeline, which runs based on code being pushed to our microservice’s repo. In this pipeline, we ideally lint our microservice’s code, we run unit tests on the code, and we test that our microservice behaves as expected in a mocked environment by also performing some component tests. Strictly speaking, these steps have nothing to do with GitOps, but they are critical for building our confidence that our microservice will behave the way we expect when it is deployed automatically later. So let’s assume that all of these steps have completed successfully in the pipeline.</p>
<p>At this point, the actual build step is executed. The build step packages our microservice into an artifact which contains all the things needed for our microservice to run. In our running example we are obviously thinking of a container image here, but there are other formats like VMs built with Packer or JAR-files or tarballs, depending on what your target platform looks like. The important thing is that the build pipeline produces one artifact which is independent of the potentially many target environments to which this artifact will be deployed. We want to build an artifact once and potentially deploy it many times.</p>
<h2 id="release">Release</h2>
<p><img src="./release.svg" alt="Diagram showing the process of tagging an artifact and then publishing it to the central store"></p>
<p>With our continuous build pipeline happily churning out artifacts based on commits of the source code, we need a second and separate step for marking certain instances of those artifacts as releases. This usually happens in a second pipeline which detects Git-tags being created in our microservice’s repository and which adds this tag to the metadata of the corresponding artifact. In our running example, this would mean tagging the container image with the version in the Git-tag.</p>
<p>The second step of the release pipeline uploads the tagged artifact to a central store, where this version of the artifact can later be referenced and pulled during deployment. Obviously again, in our running example we are thinking of an image registry here which will then be referenced from Kubernetes YAML-files when deploying our microservice together with other microservices. However, depending on your target platform you might be using a different type of store in this case, like an S3-bucket or a Maven repository. In any case, it will be something that can hold your built artifacts in different versions and serve a particular version on demand.</p>
<h2 id="deploy">Deploy</h2>
<p><img src="./deploy.svg" alt="Diagram showing artifact versions being deployed via declarative representations in Git"></p>
<p>So with our built and released artifacts nicely stored by version in a central store, we are now ready to do actual GitOps. This is where the topics of our previous two episodes come in handy. Namely, we put a pipeline in place which applies a declarative representation of our microservice architecture stored in a Git repository.</p>
<p>Whenever we update our declarative representation, say for example to make a config change, but also to introduce new versions of some microservices, we do this via the Git repository and our pipeline takes care of the deployment step. Because we are using a declarative approach, our pipeline does not need to know the procedural details of how to deploy our application. It just idempotently applies the representation and relies on the underlying technology to figure out the steps needed to reach the desired state.</p>
<p>In our example, the declarative representation are the Kubernetes YAML-files, containing deployments which reference container images. The pipeline itself is implemented in Argo CD because Argo is the most straightforward Kubernetes-native option. But again, depending on your target platform you would be using different technologies like for example GitLab-CI or Circle CI to run your pipeline.</p>
<h2 id="integration-tests">Integration Tests</h2>
<p><img src="./integration-tests.svg" alt="Diagram showing an image being tested in the int environment and being re-tagged for production"></p>
<p>But what if we need to deploy to several environments? Maybe our team needs to perform integration tests of new versions of the microservice architecture before deploying the whole thing to the production environment. This is not a problem for GitOps. In this case, we would keep a declarative representation of our microservice architecture per target environment, and create one deployment pipeline for each target environment which monitors the corresponding representation. In our Kubernetes example, you will see how we use Kustomize to manage the differences between two environments without repeating ourselves, while at the same time staying declarative.</p>
<p>So coming back to the integration test scenario, in this case we would push the representation of the int environment to our Git repo, pinning the red microservice to a new release candidate version, say <code>2.1.1-rc</code> and thus triggering its deployment. We would then perform our integration tests. Let’s assume they succeed. We would then re-tag our red microservice artifact to make it a proper release <code>2.1.1</code>. Finally, we would push the representation of the <code>prd</code> environment to our Git repo, pinning the version of the red microservice to <code>2.1.1</code> and thus triggering its deployment.</p>
<h2 id="argo-cd">Argo CD</h2>
<p>After having discussed all the steps leading up to a deployment in GitOps, we are now ready to look at an example of how this works in practice. We are going to use a simple but very awesome application on Kubernetes, and we are going to see how it is deployed and managed using Argo CD. For the purpose of our example, we have Argo CD running on our Kubernetes cluster, managing two environments of the same application. We call them <code>int</code> and <code>prd</code>.</p>
<p><img src="./argocd-application-envs.png" alt="A screenshot of Argo CD showing an int and a prd application"></p>
<p>If we click on the <code>prd</code> environment, we can see the details of how our awesome application is deployed. It consists of one Kubernetes <code>Deployment</code> resource, which runs with multiple replicas to guarantee downtime-free rolling upgrades. It also defines an <code>Ingress</code> to make it reachable from outside the cluster.</p>
<p><img src="./argocd-application-prd.png" alt="A screenshot of Argo CD showing the detailed structure of the prd environment on Kubernetes"></p>
<p>So let&rsquo;s look at how this setup is reflected as code in our <a href="https://github.com/bespinian/argocd-demo">sample repo on GitHub</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>argocd-demo <span style="color:#f92672">[</span>main<span style="color:#f92672">]</span> l
</span></span><span style="display:flex;"><span>.git
</span></span><span style="display:flex;"><span>LICENSE
</span></span><span style="display:flex;"><span>README.md
</span></span><span style="display:flex;"><span>application-int.yml
</span></span><span style="display:flex;"><span>application-prd.yml
</span></span><span style="display:flex;"><span>env
</span></span><span style="display:flex;"><span>ingress
</span></span><span style="display:flex;"><span>resources
</span></span></code></pre></div><p>In our repo, we have two YAML files called <code>application-int.yml</code> and <code>application-prd.yml</code>. These are two custom resources which are applied to our cluster in the <code>argocd</code> namespace and which tell Argo CD that there are two application environments to manage. So let&rsquo;s consider the resource for the <code>int</code> environment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">argoproj.io/v1alpha1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Application</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">argocd</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">project</span>: <span style="color:#ae81ff">default</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">source</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">repoURL</span>: <span style="color:#ae81ff">https://github.com/bespinian/argocd-demo.git</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">targetRevision</span>: <span style="color:#ae81ff">HEAD</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">path</span>: <span style="color:#ae81ff">env/int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">destination</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://kubernetes.default.svc</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">awesome-gitops-int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">syncPolicy</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">automated</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">prune</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">selfHeal</span>: <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p>As you can see, this is a resource of kind <code>Application</code>, which is a custom resource definition introduced by Argo CD. Each <code>Application</code> has a <code>source</code> which specifies the URL of the Git repo where Argo CD expects to find the setup of the application. In our case, we have also specified a <code>path</code> attribute, which tells Argo CD which sub-path of the Git repo it needs to monitor for changes. Here we are pointing to the path <code>env/int</code> where Argo CD will find a Kustomization which defines the <code>int</code> environment of our application. We could also specify a <code>targetRevision</code> here, if we wanted to pin our deployment to a branch, a tag or to a specific commit. On the other hand, Argo CD expects a <code>destination</code> element which tells it where to deploy this particular application to. In our case, we are deploying to a namespace <code>awesome-gitops-int</code> on the local cluster. Furthermore, we have also specified a <code>syncPolicy</code> which basically defines how strict Argo CD runs its GitOps process. There we have set the <code>prune</code> option, which tells Argo CD to remove any resource which it finds in the namespace <code>awesome-gitops-int</code> but which does not have a representation in the Git repo. Additionally, we have specified the <code>selfHeal</code> option, which makes Argo CD override any manual changes to resources which have a representation in the Git repo with the state committed to that repo.</p>
<p>The <code>prd</code> environment of our application is defined in its own <code>Application</code> object, where only a few parameters differ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">argoproj.io/v1alpha1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Application</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">prd</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">source</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">repoURL</span>: <span style="color:#ae81ff">https://github.com/bespinian/argocd-demo.git</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">path</span>: <span style="color:#ae81ff">env/prd</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">destination</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">awesome-gitops-prd</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">syncPolicy</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ...</span>
</span></span></code></pre></div><p>Obviously, the <code>name</code> of our the productive <code>Application</code> is different. The Git repo is the same, but the <code>path</code> points to the Kustomization for the productive environment in this case. Furthermore, the destination namespace is the productive one in this case.</p>
<p>If we check the Kustomizations of our two environments, we see that the <code>prd</code> environment is currently running version <code>1.0.0</code> of our application, whereas the <code>int</code> environment is already on version <code>2.0.0</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">kustomize.config.k8s.io/v1beta1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Kustomization</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">bases</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">../../resources</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">images</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bespinian/awesome-image</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">newTag</span>: <span style="color:#ae81ff">1.0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">configMapGenerator</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">awesome-config</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">literals</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">appTitle=Something awesome!</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">dbHost=db.bespinian.io</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">appVersion=1.0.0</span>
</span></span></code></pre></div><p>Indeed, if we have a look in <a href="https://registry.hub.docker.com/r/bespinian/awesome-image/tags">Docker Hub</a>, which is the artifact store we use for our release process in this example, we can see that there are versions <code>1.0.0</code> and <code>2.0.0</code> of the <code>awesome-image</code> which have been released by our build process.</p>
<p><img src="./argocd-dockerhub.png" alt="A screenshot of a list of images in Docker Hub"></p>
<p>So let&rsquo;s consider how we upgrade our <code>prd</code> environment to version <code>2.0.0</code> using GitOps. In order to achieve this, we simply edit our declarative representation, which in this case is our Kustomization. Let&rsquo;s assume we come up with the following new version.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">kustomize.config.k8s.io/v1beta1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Kustomization</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">bases</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">../../resources</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">images</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">bespinian/awesome-image</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">newTag</span>: <span style="color:#ae81ff">2.0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">configMapGenerator</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">awesome-config</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">literals</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">appTitle=Something even more awesome!</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">dbHost=db.bespinian.io</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">appVersion=2.0.0</span>
</span></span></code></pre></div><p>Our edits will lead to the following Git diff</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">--- a/env/prd/kustomization.yml
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/env/prd/kustomization.yml
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -4,10 +4,10 @@ bases:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   - ../../resources
</span></span><span style="display:flex;"><span> images:
</span></span><span style="display:flex;"><span>   - name: bespinian/awesome-image
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    newTag: 1.0.0
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    newTag: 2.0.0
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span> configMapGenerator:
</span></span><span style="display:flex;"><span>   - name: awesome-config
</span></span><span style="display:flex;"><span>     literals:
</span></span><span style="display:flex;"><span><span style="color:#f92672">-      - appTitle=Something awesome!
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+      - appTitle=Something even more awesome!
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>       - dbHost=db.bespinian.io
</span></span><span style="display:flex;"><span><span style="color:#f92672">-      - appVersion=1.0.0
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+      - appVersion=2.0.0
</span></span></span></code></pre></div><p>We can now commit these changes to our repo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>argocd-demo <span style="color:#f92672">[</span>main<span style="color:#f92672">]</span> git add .
</span></span><span style="display:flex;"><span>argocd-demo <span style="color:#f92672">[</span>main<span style="color:#f92672">]</span> git commit -m <span style="color:#e6db74">&#34;Roll out 2.0.0 to prd environment&#34;</span>
</span></span><span style="display:flex;"><span>argocd-demo <span style="color:#f92672">[</span>main<span style="color:#f92672">]</span> git push
</span></span></code></pre></div><p>When the Git push operation completes, Argo CD will detect our changes in the Git repo and apply them to the Kubernetes cluster, in this case using Kustomize. This can be observed in the UI of Argo CD by the fact that the <code>prd</code> environment is re-synched to our latest commit after a short while.</p>
<p><img src="./argocd-sync.png" alt="A screenshot of Argo CD syncing the prd environment"></p>
<p>This completes the deployment cycle using Argo CD and brings us to the end of the first part of this blog post on GitOps for applications.</p>
<h1 id="declarative-infrastructure">Declarative Infrastructure</h1>
<p>If your team also manages the infrastructure layer, or you are a platform team, then GitOps goes further. Every so often, the distinction between applications and infrastructure is not clear-cut. One example of that are custom VM images that contain your applications. There, it’s not so clear whether the creation and hosting of these images should be done by the application or the infrastructure team. However, as you will see, most of the concepts and workflows are very similar between application and infrastructure code.</p>
<p>We have decided to use Terraform as the running example for declarative infrastructure. But there are of course many other examples like AWS CloudFormation, Ansible Tower etc.</p>
<h2 id="repo-structure">Repo Structure</h2>
<p><img src="./repo-structure.svg" alt="A diagram showing the back-end app, the front-end app and the environments repos"></p>
<p>Obviously, there are many ways of how to structure your different components, teams and also Git repositories. One form we see a lot is to have the application-specific infrastructure with the applications themselves. So as you can see, we have an infrastructure directory in each application that contains the respective Terraform code for the application and all its dependencies like databases or message queues. By doing so, we can release the application as a whole, including its runtime and all its dependencies. All that’s separate is the configuration of the apps.</p>
<p>Since that is separate for each environment, we have a repo that consolidates each env. It instantiates each component and configures and parametrizes it for the respective environment. For example, here we have a <code>production.tf</code> file which contains all the components configured for prod. Then we have a separate <code>development.tf</code> which contains the same components, but maybe the servers are a bit less beefy, or I am using some debug options.</p>
<p>That’s also where the releasing and building of the apps and components comes in. For example, I can always use the latest versions of the back end and the front end apps in development. But for production, I may want to pin the versions. When I then create a new release, I can increment the respective version in the <code>production.tf</code> configuration, which in terms will trigger a new deployment into that environment.</p>
<h2 id="build-1">Build</h2>
<p>Let’s have a closer look at that.</p>
<p>Firstly, we want to look at the build step of your infrastructure modules. Just like for the application code, it makes sense to separate the build, the release, and the deployment phases. For Terraform, the term “build” might be a bit confusing because the code doesn’t actually need to be built. However, it still makes sense to validate and prepare your commits to be released. So maybe “prepare” would be a better name in this case.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ terraform validate
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ terraform fmt -check
</span></span></code></pre></div><p>Since infrastructure code is mostly quite heavy to test and deploy, it is important to detect problems as early as possible. A comprehensive build pipeline that performs sanity checks on your code is therefore crucial. As with any pipeline, it makes sense to run the faster and more lightweight tasks first, to fail fast if something is wrong. Terraform, for example, offers a validity check feature that checks for syntax errors in your code and fails if there are any. Similar to that, we can quickly check if the code is formatted correctly according to the Terraform community best practices. Fortunately, Terraform offers a built-in command called <code>terraform fmt</code> (probably borrowed from <code>go fmt</code>) which has a check flag. This is an effortless way of making sure our code is easy to read and understand.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ tflint <span style="color:#f92672">&amp;&amp;</span> tfsec
</span></span></code></pre></div><p>The next step after a simple sanity check is to perform some linting. Popular tools are <code>tflint</code> and <code>tfsec</code> as introduced in Part 2 of this blog series. <code>tflint</code> is a general linter, whereas <code>tfsec</code> focuses on security issues, as the name implies. Both can be customized and can bring great value by helping you and your team follow best practices around Terraform and detecting potential issues early on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ make test
</span></span></code></pre></div><p>The last step that we can do before actually releasing new versions of our infrastructure modules is to run some isolated tests. Terratest is a great tool to perform such tests. It helps you to instantiate any module in isolation, run tests on it like making HTTP requests or checking whether certain parameters have been set correctly. Then it tears down the whole deployment again.</p>
<p>In the case of Terraform, uploading our build to an artifact store is redundant, as the Git repository and its tags represent the module.</p>
<h2 id="release-1">Release</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git tag v1.0.0-rc1
</span></span></code></pre></div><p>Releasing your infrastructure modules works in a very similar way as you would do it for applications. Each module is released individually. This happens, for example, by adding a git tag that specifies a commit that we would like to release as a release candidate version.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ make integration-test
</span></span></code></pre></div><p>Our automation pipeline then picks that up and runs a suite of integration tests on our infrastructure, including the newly created release candidate. This can happen by using Terratest which can instantiate our whole environment separately and run a couple of smoke tests on that ephemeral environment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ git tag v1.0.0
</span></span></code></pre></div><p>As soon as we are happy, we then create an integration-tested release by adding another Git tag without the <code>rc</code> suffix. This marks the final release which, in Terraform’s case, doesn’t have to be uploaded anywhere because the repository itself contains the artifact which is just our infrastructure definitions at a specific commit. Now, we are ready to deploy the newly released infrastructure module.</p>
<h2 id="deploy-1">Deploy</h2>
<p>Deploying happens, as mentioned above, from a central repository which keeps track of which version of which module is deployed where. So, the deployment gets triggered by us changing the version number of a specific module, for example in the production.tf file. When we then commit and push that change, the deployment pipeline will pick that up and make the necessary changes via Terraform in the respective environment.</p>
<h2 id="example">Example</h2>
<p>Let&rsquo;s have a look at an example to see how all of this works in practice. Assume we have an application called <code>demo-app</code> which is split up into three git repositories as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>/demo-app/
</span></span><span style="display:flex;"><span>  + -- frontend
</span></span><span style="display:flex;"><span>  + -- backend
</span></span><span style="display:flex;"><span>  + -- environments
</span></span></code></pre></div><p>Furthermore, if we consider the structure of the <code>backend</code> repo, we see that it is just a normal Node.js application which contains an <code>infrastructure</code> subfolder. This subfolder contains two Terraform modules called <code>back_end</code> and <code>db</code>. The <code>back_end</code> module instantiates the complete infrastructure which the backend needs to run, in this case an AWS Lambda function and a database among other things.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>/demo-app/backend/
</span></span><span style="display:flex;"><span>  &gt; -- .github/
</span></span><span style="display:flex;"><span>  v -- infrastructure/modules/
</span></span><span style="display:flex;"><span>         v -- back_end/
</span></span><span style="display:flex;"><span>                api_gateway.tf
</span></span><span style="display:flex;"><span>                db.tf
</span></span><span style="display:flex;"><span>                dns.tf
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">function</span>.tf
</span></span><span style="display:flex;"><span>                main.tf
</span></span><span style="display:flex;"><span>                networking.tf
</span></span><span style="display:flex;"><span>                tls_certificate.tf
</span></span><span style="display:flex;"><span>                variables.tf
</span></span><span style="display:flex;"><span>         v -- db/
</span></span><span style="display:flex;"><span>                + -- db.tf
</span></span><span style="display:flex;"><span>                + -- firewalling.tf
</span></span><span style="display:flex;"><span>                + -- main.tf
</span></span><span style="display:flex;"><span>                + -- networking.tf
</span></span><span style="display:flex;"><span>                + -- outputs.tf
</span></span><span style="display:flex;"><span>                + -- variables.tf
</span></span><span style="display:flex;"><span>  &gt; -- src/
</span></span><span style="display:flex;"><span>  .env
</span></span><span style="display:flex;"><span>  .eslintrc.json
</span></span><span style="display:flex;"><span>  .gitignore
</span></span><span style="display:flex;"><span>  package-lock.json
</span></span><span style="display:flex;"><span>  package.json
</span></span><span style="display:flex;"><span>  README.md
</span></span></code></pre></div><p>The <code>db</code> module contains all the infrastructure needed for hosting the database specifically. It is instantiated in the <code>back_end</code> module by the file <code>db.tf</code> which looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#e6db74">&#34;db&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">source</span> = <span style="color:#e6db74">&#34;../db&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">environment</span>     = var.<span style="color:#a6e22e">environment</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resource_suffix</span> = var.<span style="color:#a6e22e">resource_suffix</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using this mechanism, we can separate blocks of infrastructure from each other, and parametrize each one of them via clear interfaces of Terraform inputs and outputs.</p>
<p>Our application will be rolled out to various environments. That is what the <code>environments</code> repo is for. It contains Terraform files which define the development environment, prefixed with <code>dev_</code> and Terraform files which define the productive environment, prefixed with <code>prod_</code>. Furthermore, the repo also contains some global files. These define resources which are shared across all environments, like a common monitoring stack, for example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>/demo-app/environments/
</span></span><span style="display:flex;"><span>  &gt; -- .github/
</span></span><span style="display:flex;"><span>  &gt; -- .terraform/
</span></span><span style="display:flex;"><span>  &gt; -- modules/
</span></span><span style="display:flex;"><span>  &gt; -- state/
</span></span><span style="display:flex;"><span>  .gitignore
</span></span><span style="display:flex;"><span>  .terraform.lck.hcl
</span></span><span style="display:flex;"><span>  dev_back_end.tf
</span></span><span style="display:flex;"><span>  dev_dns.tf
</span></span><span style="display:flex;"><span>  dev_front_end.tf
</span></span><span style="display:flex;"><span>  global_artifacts.tf
</span></span><span style="display:flex;"><span>  global_continous_deployment.tf
</span></span><span style="display:flex;"><span>  global_monitoring.tf
</span></span><span style="display:flex;"><span>  main.tf
</span></span><span style="display:flex;"><span>  Makefile
</span></span><span style="display:flex;"><span>  prod_back_end.tf
</span></span><span style="display:flex;"><span>  prod_dns.tf
</span></span><span style="display:flex;"><span>  prod_front_end.tf
</span></span><span style="display:flex;"><span>  README.md
</span></span><span style="display:flex;"><span>  secrets.auto.tfvars
</span></span><span style="display:flex;"><span>  variables.tf
</span></span></code></pre></div><p>Let&rsquo;s look at the file <code>dev_back_end.tf</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#e6db74">&#34;dev_back_end&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">source</span> = <span style="color:#e6db74">&#34;../backend/infrastructure/modules/back_end&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">base_domain</span>                 = <span style="color:#a6e22e">aws_route53_zone</span>.<span style="color:#a6e22e">dev</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_url</span>                      = module.<span style="color:#a6e22e">dev_db</span>.<span style="color:#a6e22e">db_url</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_vpc_id</span>                   = module.<span style="color:#a6e22e">dev_db</span>.<span style="color:#a6e22e">vpc_id</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_client_security_group_id</span> = module.<span style="color:#a6e22e">dev_db</span>.<span style="color:#a6e22e">db_client_security_group_id</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_vpc_private_subnet_ips</span>   = module.<span style="color:#a6e22e">dev_db</span>.<span style="color:#a6e22e">db_vpc_private_subnet_ips</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">dfp_api_key</span>                 = var.<span style="color:#a6e22e">dfp_api_key</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">alarms_topic_arn</span>            = module.<span style="color:#a6e22e">monitoring</span>.<span style="color:#a6e22e">alarms_topic_arn</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">environment</span>                 = <span style="color:#a6e22e">local</span>.<span style="color:#a6e22e">dev_environment</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resource_suffix</span>             = <span style="color:#a6e22e">local</span>.<span style="color:#a6e22e">dev_resource_suffix</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, the development environment is being initialized with <code>dev</code>-specific values and the source for the module is the latest commit of the <code>back_end</code> module. The latter is because we want the development environment to always have the latest state of the infrastructure. This is different, when we consider the analogous module <code>prod_back_end.tf</code> for the production environment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#e6db74">&#34;dev_back_end&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">source</span> = <span style="color:#e6db74">&#34;../backend/infrastructure/modules/back_end?ref=v2.0.0&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">base_domain</span>                 = <span style="color:#a6e22e">aws_route53_zone</span>.<span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_url</span>                      = module.<span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">db_url</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_vpc_id</span>                   = module.<span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">vpc_id</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_client_security_group_id</span> = module.<span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">db_client_security_group_id</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">db_vpc_private_subnet_ips</span>   = module.<span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">db_vpc_private_subnet_ips</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">dfp_api_key</span>                 = var.<span style="color:#a6e22e">dfp_api_key</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">alarms_topic_arn</span>            = module.<span style="color:#a6e22e">monitoring</span>.<span style="color:#a6e22e">alarms_topic_arn</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">environment</span>                 = <span style="color:#a6e22e">local</span>.<span style="color:#a6e22e">environment</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this case, we are referencing a specific version of the <code>back_end</code> module because we want our productive environment to be pinned to a certain tested state. If we look at the commit history of the <code>back_end</code> module, we can see that the version <code>v2.0.0</code> corresponds to a git tag there and that there have been more recent commits to that module in the meantime.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>commit 68e85d80a90a905d44554fedfcc621b65375c57d (HEAD -&gt; main, origin/main)
</span></span><span style="display:flex;"><span>Author: Lena Fuhrimann &lt;lena.fuhrimann@users.noreply.github.com&gt;
</span></span><span style="display:flex;"><span>Date:   Tue May 17 14:49:46 2022 +0200
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Add more awesomeness
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit cf3275a16174230a906bd536c242ee0b281b81b5
</span></span><span style="display:flex;"><span>Author: Lena Fuhrimann &lt;lena.fuhrimann@users.noreply.github.com&gt;
</span></span><span style="display:flex;"><span>Date:   Tue May 17 14:47:52 2022 +0200
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Fix a nasty bug
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 8c64e3382973a93621fdac5dd67a9080eb43b4ef (tag: v2.0.0)
</span></span><span style="display:flex;"><span>Author: Lena Fuhrimann &lt;lena.fuhrimann@users.noreply.github.com&gt;
</span></span><span style="display:flex;"><span>Date:   Tue May 17 14:33:02 2022 +0200
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Deploy a stable state
</span></span></code></pre></div><p>Finally, if we look at the frontend repo of our example app, we see that it is just a plain singe-page application which does not contain an <code>infrastructure</code> folder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>/demo-app/frontend/
</span></span><span style="display:flex;"><span>  &gt; -- .github/
</span></span><span style="display:flex;"><span>  &gt; -- public/
</span></span><span style="display:flex;"><span>  &gt; -- src/
</span></span><span style="display:flex;"><span>  .env
</span></span><span style="display:flex;"><span>  .gitignore
</span></span><span style="display:flex;"><span>  package-lock.json
</span></span><span style="display:flex;"><span>  package.json
</span></span><span style="display:flex;"><span>  README.md
</span></span></code></pre></div><p>This is because single-page applications have a very generic way of being deployed, and we can thus use an existing third-party Terraform module for this. We can see how this is done in the file <code>dev_front_end.tf</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-terraform" data-lang="terraform"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#e6db74">&#34;dev_front_end&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">source</span> = <span style="color:#e6db74">&#34;github.com/cloudlena/terraform-spa?ref=1.0.2&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">providers</span> = {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">us_east</span> = <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">us_east</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">service_name</span>    = <span style="color:#e6db74">&#34;cp_front_end&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">domain</span>          = <span style="color:#a6e22e">aws_route53_zone</span>.<span style="color:#a6e22e">dev</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">environment</span>     = <span style="color:#a6e22e">local</span>.<span style="color:#a6e22e">dev_environment</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">resource_suffix</span> = <span style="color:#a6e22e">local</span>.<span style="color:#a6e22e">dev_resource_suffix</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, we can reference any third-party module which is hosted on GitHub as the module&rsquo;s source.</p>
<h1 id="advanced-concepts">Advanced Concepts</h1>
<p>GitOps itself is a very intriguing concept that can bring great value and stability to your projects. However, there are some even more advanced concepts that we would like to explore a bit at this point to give you some ideas of what you can do once you’ve achieved stable GitOps workflows.</p>
<h2 id="true-continuous-deployment">True Continuous Deployment</h2>
<h3 id="every-commit-gets-deployed-automatically">Every commit gets deployed automatically</h3>
<p>So far, we have only talked about deploying specifically tagged or otherwise marked releases. However, there is another interesting concept around GitOps, which is called “Continuous Deployment”. True continuous deployment means that every commit to a branch is directly deployed into one or multiple environments. Yes, sometimes even productive ones. For example, my team could have a single <code>main</code> branch and all changes to it go directly into production. So, there’s no specific versioning, tagging or releasing. My team and I are confident that any change we make is safe to go to prod.</p>
<h3 id="importance-of-testing">Importance of testing</h3>
<p>Obviously, it takes either a great ego or some serious testing coverage to get to the confidence level of releasing everything into prod. Good test coverage on a unit, an integration and an end-to-end level is crucial to releasing often.</p>
<h3 id="requires-feature-flags-and-a-rigid-git-model">Requires feature flags and a rigid Git model</h3>
<p>Another important point to consider is that we might have features which are on our main branch but which we don’t want our end users to see yet. For that, feature flags can be helpful. In the simplest case, this means that we have an <code>if</code> statement in our code that checks if a specific feature should be enabled in that environment and only displays the new feature if that flag is enabled. By doing so, we can control the features and their availability in different environments independently of our code releases.</p>
<h3 id="people-mostly-do-continuous-deployment-in-non-prod-environments">People mostly do continuous deployment in non-prod environments</h3>
<p>At this time, many people do true continuous deployment in non-productive environments. It takes a lot of maturity and courage to move this process to productive environments, but we can only encourage you to strive to do so.</p>
<h2 id="chatops">ChatOps</h2>
<p><img src="./chatops.svg" alt="The logos of Slack and Rocket Chat"></p>
<p>Another fun concept and buzzword is “ChatOps”. It means that we can trigger certain steps of our automation pipelines by using our normal communication tools. So, for example, we could have a Slack or Rocket Chat instance that we also use for our usual team communication. In there, we could have a “deployment” channel, where people simply have to type “Deploy production” as a chat message. Our automation server listens on that channel for certain messages and, as soon as they get posted, does its thing.</p>
<p>This is not as thoroughly automated as pure GitOps because there’s the manual step of writing a chat message. However, a combination of GitOps and ChatOps can be interesting. For example, the deployment into development and staging environments happens fully automated via GitOps and there’s no manual user interaction needed. For the deployment into production, however, we want to be a bit more cautious and only trigger the deployment after we’ve done thorough manual testing. This means that we can do this testing, and only after everybody is happy, we trigger the deployment via chat message.</p>
<h2 id="security">Security</h2>
<h3 id="audit-trail">Audit Trail</h3>
<p>GitOps brings great benefits in terms of security. By tracking all the changes to your applications but also your infrastructure in Git, you get a clear audit trail of what was done when by whom. To get this benefit, it is crucial to only accept signed commits to ensure that the person who claims to have made a commit actually did. This can be done via GPG and is supported by most Git server providers like GitHub.</p>
<h3 id="linting-and-pull-requests">Linting and Pull Requests</h3>
<p>Another benefit in terms of security is that you get to lint and code review all of your code and therefore ensure that you follow best practices and don’t have any security holes that can be detected easily by static code analysis or by your colleagues looking over the code. All changes go through the team and are rolled out in a structured way.</p>
<h3 id="clear-and-concise-overview-of-code">Clear and Concise Overview of Code</h3>
<p>Furthermore, GitOps always gives you an up-to-date summary of what is deployed where and how your infrastructure and applications are configured. This is great for manual security audits and simply to review your code as a team from time to time.</p>
<h1 id="thanks">Thanks!</h1>
<p>This brings us to the end of this three part blog series. We highly appreciate your interest and are excited for your comments and questions.</p>
<p>As a last important takeaway, please be aware that different teams might be at different maturity levels. Usually, application teams are rather quick at adopting such deployment and lifecycle strategies. So, it’s possible that your apps are already deployed using GitOps, but your infrastructure is still maintained traditionally, for example using a GUI and clicking around. This gap can be dangerous because the infrastructure might not be able to keep up with the fast pace of change GitOps allows the application teams to follow. Therefore, it is important to be aware of this gap and communicate clearly among the different teams and components that make up your environments.</p>


		<div
  class="bespinian-social-nav-container bespinian-social-nav-container--footer"
>
  <nav class="bespinian-social-nav">
    
    <a class="bespinian-social-nav-link" href="https://bespinian.io/">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian website">
          <title>bespinian website</title>
          <use href="/icons/globe.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://github.com/bespinian">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on GitHub">
          <title>bespinian on GitHub</title>
          <use href="/icons/github.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://twitter.com/bespinian">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on Twitter">
          <title>bespinian on Twitter</title>
          <use href="/icons/twitter.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="https://www.youtube.com/channel/UCBQD1IedufccsRXqC_hypyg/playlists">
      <span class="bespinian-icon">
        <svg role="img" aria-label="bespinian on YouTube">
          <title>bespinian on YouTube</title>
          <use href="/icons/youtube.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
    <a class="bespinian-social-nav-link" href="/index.xml">
      <span class="bespinian-icon">
        <svg role="img" aria-label="The bespinian blog RSS feed">
          <title>The bespinian blog RSS feed</title>
          <use href="/icons/rss.svg#glyph"></use>
        </svg>
      </span>
    </a>
    
  </nav>
</div>

	</div>

	<div class="pagination">
		<a href="/posts/observability-in-the-cloud/" class="left arrow">&#8592;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        		<footer>
			
            <figure class="article-discussion">
              <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "berndsgnch" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            </figure>
			
			<span>
			&copy; <time datetime="2022-06-16 16:17:10.307111267 &#43;0200 CEST m=&#43;0.180148184">2022</time> bespinian. Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
